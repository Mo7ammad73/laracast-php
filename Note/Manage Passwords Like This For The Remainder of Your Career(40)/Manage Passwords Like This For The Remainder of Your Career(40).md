این جلسه از آموزش Laracasts درباره امنیت رمز عبور در PHP و نحوه استفاده از **هشینگ رمز عبور** با الگوریتم bcrypt است؛ در این جلسه از ذخیره رمز‌های عبور به صورت متنی (clear text) دوری شده و نحوه اصلاح کدها برای امنیت بیشتر آموزش داده می‌شود.

## اهمیت هشینگ رمز عبور

در آغاز ویدیو تاکید می‌شود **هرگز رمز عبور کاربران را به صورت ساده در دیتابیس ذخیره نکنید**؛ این کار یکی از بزرگ‌ترین ریسک‌های امنیتی است و باعث فاش شدن اطلاعات در صورت رخداد افشای داده‌ها خواهد شد.

---

## ۱. `password_hash()` چی کار می‌کنه؟

این تابع برای **هش کردن رمز عبور** است.  
یعنی رمز خام کاربر (مثلاً `123456`) را به یک رشته پیچیده و غیرقابل برگشت تبدیل می‌کند.
```php
$hash = password_hash("123456", PASSWORD_DEFAULT);
echo $hash;
```
خروجی چیزی شبیه این می‌شود:
```text
$2y$10$uZRm6c2ZkxD4gTkx7vqGeu.WEF5GQxFTUbiR6P6ztUnWAtc79y4U6
```
🔑 مهم: این رشته هر بار که اجرا کنی فرق می‌کند، چون خودش **salt** تصادفی تولید می‌کند.  
(این یعنی امنیت بالا.)
خروجی `password_hash()` شامل 4 آیتم هست :
1. **الگوریتم** → نشون میده با چی ساخته شده (مثلاً bcrypt یا argon2).
2.  کلمه **cost** → سختی محاسبه پیش فرض 10 هست برای مقدار دادن
```php
password_hash("123456", PASSWORD_DEFAULT, ["cost" => 12]);
```
1. کلمه **salt** → رشته‌ی تصادفی برای منحصر‌به‌فرد شدن. یعنی هر سری یک رشته ی تصادفی به رمز هش  اضافه میکند.
2. کلمه **hash** → نتیجه‌ی نهایی رمزگذاری.
```php
$2y$10$KX1sPyVv6j3fH0HRPJX0Iu8Cq6DRZGiHgU8ePR14yI8bnYJeqEgrK
│ │  │  └──────────────┬─────────────────────────────────────┘
│ │  │                 │
│ │  │                 └─ (Salt + Hash)
│ │  └─ Cost (rounds)
│ └─ الگوریتم (Bcrypt)
└─ شروع نشانه

```

---
## ۲. استفاده‌اش کجاست؟
- **ثبت‌نام کاربر**: وقتی کاربر رمز را می‌فرستد، آن را با `password_hash()` تبدیل می‌کنی و در دیتابیس ذخیره می‌کنی.
- **ورود کاربر**: وقتی دوباره رمز را وارد کرد، با `password_verify()` چک می‌کنی که درست است یا نه.

---

## 3. ثبت‌نام (ذخیره رمز هش‌شده)

```php
$password = $_POST['password']; // رمز خامی که کاربر وارد کرده
$hash = password_hash($password, PASSWORD_DEFAULT); // تبدیل به هش

// ذخیره در دیتابیس
$stmt = $pdo->prepare("INSERT INTO users (username, password) VALUES (?, ?)");
$stmt->execute([$_POST['username'], $hash]);
```

---
۴. ورود (بررسی رمز)
## تابع`password_verify()` چی کار می‌کنه؟

این تابع برای **مقایسه رمز خام کاربر** با هش ذخیره‌شده در دیتابیس استفاده می‌شه.
چون هش هر بار فرق می‌کنه، نمی‌تونی با `==` یا `===` مقایسه کنی.  
مثال:
```php
$hash = password_hash("123456", PASSWORD_DEFAULT);

if ("123456" === $hash) {
    echo "درسته!";
} else {
    echo "غلطه!";
}
//روش بالا کلا غلط هست پس خروجی همیشه غلطه
//روش درست در پایین

$hash = password_hash("123456", PASSWORD_DEFAULT);

// موقع ورود:
if (password_verify("123456", $hash)) {
    echo "رمز درست است ✅";
} else {
    echo "رمز اشتباه است ❌";
}

```
اما برای اینکه رمز عبور را از پایگاه داده بدست آوریم ابتدا کاربر که username وارد شده در فرم با username یکی از رکوردهای جدول user برابر بود آن کاربر را به ما میدهد همراه همه فیلدهاش پس پسورد هم هست حالا میاد با password_vrify مقایسه میکنی این پسوردی که ما در پایگاه داده داریم والان بدستش آوردیم هش شده هست این تابع این پسورد را ازحالت هش خارج و مقدارخام قبلیش را با مقداری که کاربر در فرم وارد کرده مقایسه میکند.

```php
// از دیتابیس هش را می‌گیریم
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = ?");
$stmt->execute([$_POST['username']]);
$user = $stmt->fetch();

if ($user && password_verify($_POST['password'], $user['password'])) {
    echo "ورود موفق";
} else {
    echo "نام کاربری یا رمز اشتباه است";
}

```
وقتی `password_verify` اجرا میشه:
```php
if (password_verify("123456", $hash)) {
    echo "رمز درسته ✅";
} else {
    echo "رمز اشتباه ❌";
}
```
چی میشه پشت صحنه؟
- برنامه  PHP اون `$hash` رو می‌خونه.
- ازش **الگوریتم، cost و salt** رو درمیاره.
- حالا دوباره رمز خامی که کاربر داد (`123456`) رو با همون **الگوریتم + cost + salt** هش می‌کنه.
- خروجی‌ای که تولید می‌کنه باید دقیقاً مساوی همون بخش "hash" قبلی بشه.
  ✅ پس درست گفتی:  `password_verify` با استفاده از اون ۳ بخش (الگوریتم + cost + salt) دوباره هش می‌سازه و با هش قبلی مقایسه می‌کنه.

---

### 3. نتیجه

🔹 اگر همون رمز درست وارد شده باشه → هش جدید = هش ذخیره‌شده → برمی‌گردونه `true`.  
🔹 اگر رمز اشتباه وارد بشه → هش جدید فرق می‌کنه → برمی‌گردونه `false`.

---

## ۵. چرا مستقیم رمز را ذخیره نمی‌کنیم؟
- چون اگر دیتابیس لو برود، همه رمزها لو می‌روند.
- ولی اگر هش ذخیره شود، حتی خودت هم رمز اصلی را نمی‌توانی بفهمی.

---


به فایل index.view.php رفته و در بخش main  کد زیر را مینویسیم:

```php
<p>  <?= $_SESSION['user']['email'] ?? 'Guest' ?></p>
```
این کد مقدار ایمیل ثبت‌شده در session را نمایش می‌دهد و اگر کاربری وارد نشده باشد، متن "Guest" را نشان می‌دهد.

---
## هشینگ رمز عبور هنگام ثبت نام

در مرحله بعد، فایل store.php که مسئول ثبت نام کاربر است به این شکل اصلاح شد:
```php
$db->query("INSERT INTO users (email, password) values (:email, :password)", [':email' => $email, ':password' =>password_hash($password,_PASSWORD_BCRYPT_)]);
//password->$password  قبل از تغییر به این شکل پسورد ذخیره میشد.
```
در واقع از تابع password_hash استفاده شد و داخلش یک آرگومان خود پسوورد و یک آرگومان PASSWORD_BCRYPT هست که یک شیوه رمزگذاری میباشد.در این کد، قبل از ذخیره رمز عبور، با تابع `password_hash` و الگوریتم `PASSWORD_BCRYPT`، رمز عبور به صورت امن هش می‌شود و نه به صورت متن ساده در پایگاه داده ذخیره می‌شود.

---
## توضیحات جزوه‌ای گام به گام

## ۱. نمایش اطلاعات کاربر در صفحه اصلی

- در فایل `index.view.php`، داخل تگ main یا بخش مورد نظر، قطعه کد زیر قرار داده می‌شود:
```php
<p><?= $_SESSION['user']['email'] ?? 'Guest' ?></p>
```
- کاربرد: اگر کاربری وارد شده باشد ایمیل وی نمایش داده می‌شود، اگر نه "Guest" نشان داده می‌شود.
## ۲. اصلاح ثبت‌نام برای هشینگ رمز عبور

- به فایل `store.php` مراجعه کرده و کوئری مربوط به ذخیره کاربر را اصلاح می‌کنیم تا رمز عبور هش شود:
```php
$db->query("INSERT INTO users (email, password) values (:email, :password)", [
    ':email' => $email,
    ':password' => password_hash($password, PASSWORD_BCRYPT)
]);
```
- در اینجا تابع `password_hash` رمز عبور را با استفاده از الگوریتم bcrypt هش می‌کند و مقدار هش شده در دیتابیس ذخیره می‌شود.
## ۳. توضیح درباره الگوریتم‌های هشینگ

- تابع `password_hash` در PHP به طور پیش‌فرض از bcrypt استفاده می‌کند.
- برای استفاده قطعی از bcrypt، از ثابت `PASSWORD_BCRYPT` در آرگومان دوم تابع استفاده می‌شود.
- مقدار رمز عبور حتی در صورت افشای جدول کاربران، به راحتی قابل رمزگشایی نیست؛ چون هش کردن و مخصوصاً استفاده از bcrypt بسیار امن است.

## ۴. چرا نباید رمز عبور را به صورت متنی ذخیره کرد؟

- اگر رمزها به صورت ساده ذخیره شوند، در هر افشای اطلاعات به راحتی قابل سوءاستفاده توسط هکرها خواهند شد.
- با هش کردن رمز عبور حتی اگر داده‌ها افشا شوند، رمزها به سختی قابل کرک شدن هستند.

## جمع‌بندی

در این جلسه ثبت نام کاربر و نمایش اطلاعات با استفاده از session بهبود یافت، و بخش حیاتی امنیت یعنی هشینگ رمز عبور با bcrypt به پروژه اضافه شد؛ این موضوع باید همیشه در هر سامانه ثبت نام رعایت شود تا امنیت کاربران حفظ گردد.

---

عنوان جلسه: امنیت پسوردها و هش کردن (Password Security and Hashing)

مقدمه

در این جلسه، تمرکز بر روی بهبود امنیت سیستم ثبت‌نام با پیاده‌سازی هش کردن پسوردها است. مدرس ابتدا یک مشکل امنیتی مهم را توضیح می‌دهد و سپس راه‌حل آن را ارائه می‌کند.

---

بخش ۱: وضعیت فعلی سیستم

·         در حال حاضر سیستم ثبت‌نام و یک پیاده‌سازی ساده از route middleware فعال است.

·         پسوردها به صورت متن ساده (clear text) در دیتابیس ذخیره می‌شوند که یک مشکل امنیتی جدی است.

**مثال از مشکل امنیتی****:
```text
email= joe@joe.com
password=mypassword123     متن ساده
```

---
بخش ۲: اضافه کردن فیدبک به کاربر

برای بهبود UX، یک پیام خوش‌آمدگویی به صفحه اصلی اضافه می‌شود:

**فایل****: index.view.php
```php
<p>Hello <?= $_SESSION['user']['email'] ?? 'Guest' ?></p>
```
**توضیح****:
·         اگر کاربر لاگین کرده باشد، ایمیل او نمایش داده می‌شود
·         در غیر این صورت کلمه "Guest" نمایش داده می‌شود

---

بخش ۳: مشکل امنیتی پسوردها

·         **هرگز** پسوردها را به صورت متن ساده در دیتابیس ذخیره نکنید
·         این practice یک نگرانی امنیتی جدی محسوب می‌شود
·         در صورت نفوذ به دیتابیس، حمله‌کنندگان به تمام اطلاعات کاربران دسترسی پیدا می‌کنند

---

بخش ۴: راه‌حل - هش کردن پسوردها

با استفاده از تابع password_hash در PHP این مشکل حل می‌شود.

**فایل:** store.php **(قبل از اصلاح)**

```php
$db->query("INSERT INTO users (email, password) values (:email, :password)", [

    ':email' => $email,

    ':password' => $password _//_ _متن ساده__!_

]);
```

**فایل:** store.php **(بعد از اصلاح)**

```php
$db->query("INSERT INTO users (email, password) values (:email, :password)", [

    ':email' => $email,

    ':password' => password_hash($password, PASSWORD_BCRYPT)

]);
```
---

بخش ۵: توضیح تکنیکال

**تابع** password_hash**:
·         پارامتر اول: پسورد کاربر (متن ساده)
·         پارامتر دوم: الگوریتم هش کردن

دستور PASSWORD_DEFAULT: الگوریتم پیش‌فرض (در حال حاضر bcrypt)
دستورPASSWORD_BCRYPT: الگوریتم bcrypt به طور خاص

**مزایای** **bcrypt:**

الگوریتمی بسیار امن و مطمئن
 کلمه cracking آن بسیار زمان‌بر و دشوار است
استاندارد صنعتی برای ذخیره‌سازی پسوردها

---

بخش ۶: تست نتیجه

پس از اعمال تغییرات:
1.     حساب کاربری قدیمی حذف می‌شود
2.     کاربر جدید ثبت می‌شود
3.     در دیتابیس به جای پسورد明文، hash آن ذخیره می‌شود

**نتیجه در دیتابیس****:

```sql
email: joe@joe.com

password: $2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi _--_ _هش شده__!_

```
---

نکات مهم پایانی

1.     **امنیت اولویت اول****:** هرگز پسوردها را به صورت متن ساده ذخیره نکنید
2.     **همیشه از هش استفاده کنید****:** این practice باید برای تمام سیستم‌های ثبت‌نام اعمال شود
3.     **الگوریتم به روز****: از الگوریتم‌های استاندارد و به روز استفاده کنید
4.     **تست :** همیشه نتیجه را در دیتابیس verify کنید

---

این پیاده‌سازی امنیت سیستم شما را به طور قابل توجهی افزایش می‌دهد و از اطلاعات کاربران در برابر نفوذهای احتمالی محافظت می‌کند.