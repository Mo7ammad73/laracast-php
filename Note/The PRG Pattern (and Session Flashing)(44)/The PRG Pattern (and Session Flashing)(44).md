**.** **مشکل اصلی**
وقتی کاربر فرم ورود (Login) رو پر می‌کنه و اعتبارسنجی (validation) شکست می‌خوره یعنی پسوورد یا رمز عبور یا هردو اشتباه زده شود  یا اعتبارسنجی فیلدها دارای خطا باشد (مثلا تو رمز عبور از حروف بزرگ انگلیسی استفاده شده باشد):
- ما  توسط فایل store دوباره همون فرم log in  رو با خطاهاش برمیگردونیم دستور زیر را برمیگردانیم:
```php
return view("sessions/create.view.php" ,['error' => $form->getErrors()] );
```
- ما فقط **یک** **View (HTML)** برمی‌گردونیم (return view).
- این یعنی پاسخ **یک** **Post request → HTML** هست.
- مشکل اول: اگر کاربر صفحه رو Refresh کنه، مرورگر دوباره Post می‌فرسته → احتمال **ارسال دوباره فرم**.یعنی هربار که Refresh میکنه انگار دکمه log in زده میشه.
- مشکل دوم: اگر کاربر به صفحه‌ی دیگری بره و بعد دکمه Back رو بزنه → مرورگر خطای **Document Expired** نشون می‌ده.
---
#### فرق خطای Confirm Form Resubmission با Document Expired در مرورگر
#### خطای Confirm Form Resubmission

- این پیغام وقتی ظاهر می‌شود که کاربر یک فرم را با متد POST ارسال کرده و بعد دکمه Reload یا Back مرورگر را بزند.
- مرورگر برای جلوگیری از ارسال مجدد داده (مثلاً تراکنش مالی یا ثبت فرم تکراری)، این پیام تأییدی را نشان می‌دهد که آیا واقعاً می‌خواهد دوباره داده‌ها را ارسال کند.
- معمولاً برای محافظت از کاربر است تا اطلاعات مهم یا حساس دوبار ارسال نشود.
#### خطای Document Expired
- این پیام زمانی می‌آید که صفحه‌ای که کاربر به آن باز می‌گردد (مثلاً با Back یا Reload روی صفحات حساس یا فرم‌ها)، دیگر در کش مرورگر موجود نیست یا مرورگر به دلایل امنیتی اجازه نمایش مجدد آن را نمی‌دهد.
- مثلاً اگر یک فرم با داده حساس ارسال شود و بعد بخواهید با Back برگردید، مرورگر می‌گوید "این سند منقضی شده است" تا از نمایش ناخواسته اطلاعات جلوگیری کند.
- معمولاً نیاز به بارگذاری مجدد صفحه (refresh) خواهد بود و گاهی اوقات هم اصلاً دیگر آن صفحه در دسترس نخواهد بود.
## جدول مقایسه

| پیام                      | علت اصلی                       | چه زمانی رخ می‌دهد                        | رفتار کاربر یا مرورگر                                                                                                          |
| ------------------------- | ------------------------------ | ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| Confirm Form Resubmission | ارسال مجدد فرم با POST         | Reload یا Back بعد از سابمیت فرم          | پرسش تأیید برای جلوگیری از ارسال مجدد داده[](https://www.addictivetips.com/windows-tips/confirm-form-resubmission-on-refresh/) |
| Document Expired          | سند کش‌شده پاک شده یا حساس است | برگشت یا فورواراد روی صفحات حساس یا منقضی | نمایش اخطار و اغلب نیاز به reload یا برگشت به صفحه قبلی[](https://support.mozilla.org/si/questions/1414072)                    |

در نتیجه، پیام Confirm Form Resubmission درباره ارسال دوباره فرم و جلوگیری از داده تکراری است؛ درحالی که Document Expired بیشتر به خاطر امنیت و پاک شدن صفحات کش‌شده برای جلوگیری از دوباره نمایش داده حساس هشدار می‌دهد.

---
### راه‌حل (الگوی **PRG = Post → Redirect → Get**)

1. کاربر فرم رو **POST** می‌کنه.(P)
2. سرور اگر خطا داشت (مثلاً اعتبارسنجی fail شد)، به جای اینکه همونجا ویو رو `return` کنه، باید **Redirect** کنه (مثلاً به `/login`). این Redirect یه پاسخ با **کد 302** می‌ده.(R)
3. مرورگر وقتی Redirect رو دید، خودش یه **GET** درخواست جدید به `/login` می‌زنه.(G)
4. حالا صفحه Login از نو لود میشه (بدون ریسک تکرار POST).
### چرا این بهتره؟

- دیگه با رفرش، دوباره POST نمی‌شه → خطای "Confirm Form Resubmission" از بین میره.
- دکمه Back/Forward مرورگر درست کار می‌کنه.
- جلوی ارسال چندباره‌ی فرم گرفته میشه.

🔑 خلاصه:  
مشکل اصلی اینه که وقتی توی متد `store` مستقیم `return view()` می‌زنیم، مرورگر فکر می‌کنه نتیجه‌ی **POST** یه صفحه است و با هر Refresh می‌خواد همون POST رو تکرار کنه.  
الگوی **PRG** این رو حل می‌کنه:

- حرف **P**: فرم POST میشه.
- حرف **R**: سرور Redirect می‌کنه (۳۰۲).
- حرف **G**: مرورگر دوباره GET می‌کنه و صفحه لود میشه.
---
## منظور از ریدایرکت با کد 302 چیه؟
### کدهای وضعیت (HTTP Status Codes)

هر بار سرور پاسخی به مرورگر می‌ده، همراهش یک **Status Code** هم می‌فرسته.  
مثلاً:
- کد `200 OK` → یعنی درخواست موفق بود.
- کد `404 Not Found` → یعنی صفحه پیدا نشد.
- کد `500 Internal Server Error` → یعنی خطای سمت سرور.

---
### کد 302 (Found / Redirect)
وقتی سرور بخواد به مرورگر بگه:  
«اینجا جواب اصلی نیست، برو یه آدرس دیگه رو درخواست کن» → از **کد 302** استفاده می‌کنه.
به این می‌گیم **Redirect (انتقال)**.

---
### مثال ساده
فرض کن توی متد `store` بعد از بررسی فرم لاگین، رمز عبور اشتباه باشه:
```php
public function store()
{
    // فرض: اعتبارسنجی انجام شد و خطا داشت
    return redirect('/laracast-php/public/login'); // اینجا لاراول خودش 302 می‌فرسته
}
```

این پاسخ HTTP چیزی شبیه این میشه:
```text
`HTTP/1.1 302 Found Location: /laracast-php/public/login`
```
مرورگر وقتی اینو دید:
1. متوجه میشه سرور گفته "اینجا نه، برو یه جای دیگه".
2. خودش یه درخواست جدید به `/laracast-php/public/login` با متد **GET** می‌فرسته.
3. نتیجه → صفحه لاگین دوباره لود میشه بدون اینکه POST تکرار بشه.
---
### چرا مهمه؟
- اگر `200` باشه (یعنی همونجا ویو برگرده) → مرورگر فکر می‌کنه نتیجه‌ی POST همین HTML بوده. با Refresh، دوباره POST تکرار میشه.
- اگر `302` باشه → مرورگر سریع میره به یه GET جدید. پس مشکل **Confirm Form Resubmission** حل میشه.
  یعنی **302 پلی بین POST و GET** هست.
---

## بریم برای حل مشکل
به فایل store رفته  قبلا کد ما به صورت زیر بود:
```php
return view("sessions/create.view.php" ,
['error' => $form->getErrors()] 
);
```
یعنی مستقیماً همون HTML ویو لاگین رو برمی‌گردوندیم (با status code 200).
الان :
```php
return Redirect("/laracast-php/public/login");
```
یعنی یه **302 Redirect** برمی‌گردونیم به مرورگر. مرورگر میره دوباره با laracast-php/public/login   GET   رو میاره.

---
### مشکل جدید
خب حالا با این روش مشکل **Confirm Form Resubmission** حل شد ✅  
ولی یه سؤال مهم پیش اومد:  
وقتی ما Redirect کردیم، اطلاعات خطا (مثل "رمز عبور اشتباه است") دیگه توی ریکوئست جدید وجود نداره ❌
- قبلش ما `$errors` رو مستقیم می‌دادیم به ویو.
- ولی الان چون یه درخواست جدید (GET) زده میشه، دیگه اون `$errors` از بین میره.
### راه‌حل: استفاده از **Session**
جفری اینجا میگه:  
«یادتونه چند جلسه قبل یاد گرفتیم از **Session** استفاده کنیم؟ خب الان دقیقاً همونه. ما باید خطاها رو بذاریم داخل Session، بعد توی صفحه بعدی (GET login) اونا رو بخونیم و نشون بدیم.»
این دقیقاً همون کاریه که لاراول توی پشت‌صحنه انجام میده.
پس در فایل store  کد زیر را مینویسیم:
```php
$_SESSION['error'] = $form->getErrors();  
return Redirect("/laracast-php/public/login");
```
بعد به پوشه http/controller/sessions رفته و در فایل create.php  مقدار session رو پاس میدهیم:
```php
view("sessions/create.view.php",['error' => $_SESSION['error'] ?? [] ]);
```
حالا خطاها هم نمایش داده میشود ولی مقدارشان پاک نمیشود اگر بر روی یک منوی دیگر برویم بعد دوباره به loginبرگردیم میبینیم که همون خطاها نمایش داده میشوند برای حل این مشکل:
### ۱. ذخیره کردن خطا قبل از ریدایرکت
در متد `store` (جایی که فرم login پردازش میشه):
- اگر اعتبارسنجی fail شد → قبل از `redirect` کردن، خطاها رو می‌ذاریم داخل Session.
```php
$_SESSION ['_flashed']['error'] = $form->getErrors();  
return Redirect("/laracast-php/public/login");
```
### ۲. استفاده از Session در کنترلر login
وقتی دوباره GET به `/login` میاد:
- ما توی کنترلر login، خطاها رو از Session می‌خونیم.
- منظور از کنترلر login همون فایل create.php هست .
- حالا error شامل مقادیر خطاها هست و در فایل create.view قابل استفاده هست.
```php
view("sessions/create.view.php",['error' => $_SESSION['_flashed']['error'] ?? [] ]);
```
### ۳. پاک کردن داده‌های فلش بعد از یک بار استفاده
ایرادی که جفری گفت: اگه همینجوری بذاریم، این خطاها برای کل طول عمر session می‌مونن ❌  
پس باید **بعد از اینکه یک بار ویو لاگین رو لود کردیم، خطاها رو حذف کنیم**.
این کار رو توی نقطه‌ی ورود (index.php) بعد از اجرای متد `route` انجام داد:
```php
$router->route($url, $method);  
unset($_SESSION['_flashed']);
```
### نتیجه
- خطاها فقط برای **درخواست بعدی** در دسترس هستن.
- بعدش خودکار پاک می‌شن.
- به این می‌گیم **flash data** (برعکس session معمولی که تا پایان session مرورگر باقی می‌مونه).
---
##### . چرا جفری `$_SESSION['_flash']` معرفی کرد (مگه با `$_SESSION['error']`نمیشد)؟

جفری این کارو کرد که **فرق بین داده‌های معمولی session و داده‌هایی که فقط موقتی هستن (flash data)** مشخص باشه.
- بعضی داده‌ها مثل **user_id** باید برای کل عمر session بمونن.
- بعضی داده‌ها مثل **validation errors** فقط برای یک درخواست بعدی لازمن و باید بعدش حذف بشن.
  اگه همه‌چیزو با یه اسم مثل `$_SESSION['errors']` ذخیره کنیم:
- تشخیص اینکه کدوم داده دائمیه و کدوم موقتی، سخت میشه.
- ممکنه اشتباهی یه جای دیگه `errors` استفاده کنیم و همدیگه رو override کنن.
---
### فلسفه‌ی `flash` در فریم‌ورک‌ها

لاراول هم دقیقاً همین کارو می‌کنه:
- داده‌های دائمی → داخل session معمولی.
- داده‌های موقتی → داخل flash session.
  چون flash یک مفهومیه که میگه:  
  «این داده فقط برای **next request** معتبره. بعدش پاک کن.»
### چرا `_flash`؟
اون underscore (یا حتی دوتا `__`) فقط برای اینه که احتمال تداخل با کلیدهای session معمولی کم بشه.  
مثلاً شاید خودت یه روز `$_SESSION['errors']` برای چیزی غیر از validation بزنی. با `_flash['errors']` دیگه قاطی نمیشه.

---
# کلاسsession
###  چرا کلاس Session ساخته شد؟
قبلاً ما مستقیم با `$_SESSION` کار می‌کردیم:
```php
$_SESSION['errors'] = ['Invalid email'];
```
ولی مشکل این بود که:
- مجبور بودیم مدام کلیدها (`_flashed`، `errors` و …) رو در جاهای مختلف تکرار کنیم → سخت نگهداری.
- نمی‌تونستیم رفتارهای خاص مثل **flash شدن** (فقط یک درخواست عمر داشته باشه) رو به‌سادگی مدیریت کنیم.
- کد شلوغ و غیرمنعطف می‌شد.
  برای همین Jeff اومد یک **کلاس Session** نوشت تا همه این کارها متمرکز بشن.
---
### 2. متدهای پایه‌ای

🔹 متد **put** → چیزی داخل سشن بذاره
```php
public static function put($key, $value) {
    $_SESSION[$key] = $value;
}
```
🔹متد **get** → چیزی از سشن بگیره (با امکان تعیین مقدار پیش‌فرض اگر وجود نداشت)
```php
public static function get($key , $default = null){  
    return $_SESSION['_flashed'][$key] ?? $_SESSION[$key] ?? $default;  
}
```
🔹 متد **has** → بررسی کنه کلیدی توی سشن هست یا نه
```php
public static function has($key) {
    return isset($_SESSION[$key]);
}
//or
public static function has($key){  
    return bool(static::get($key));  
}
```
### متد Flash
```php
public static function flash($key , $value){  
    $_SESSION['_flashed'][$key] = $value;  
}
```

این بخش همونیه که قبلاً دستی انجام می‌دادیم:
```php
$_SESSION['_flashed']['errors'] = ['Invalid email'];
```
حالا می‌شه راحت گفت:
```php
Session::flash('errors', ['Invalid email']);
```
و کلاس خودش می‌فهمه که باید داخل `$_SESSION['_flashed']` ذخیره بشه.

---
###  متد Unflash
وقتی صفحه جدید لود شد، فلش‌ها باید پاک بشن (چون فقط یک بار باید نمایش داده بشن).  
برای همین یک متد **unflash** گذاشت:
```php
public static function unflash() {
     unset($_SESSION['_flashed']);
 }
```

دیگه نیازی نیست توی هر صفحه دستی `unset($_SESSION['_flashed'])` بنویسیم.
### دسترسی به Flash در get

مدرس Jeff نمی‌خواست جای دیگه‌ها بدونن کلید `_flashed` وجود داره.  
پس داخل **get** یک چک اضافه کرد:
- اول بررسی کن کلید توی `_flashed` هست یا نه.
- اگر نبود، برو توی سطح اصلی `$_SESSION`.
- اگر باز هم نبود → مقدار پیش‌فرض رو برگردون.
  یعنی کدی مثل:
```php
$errors = Session::get('errors');
```
خودش می‌فهمه باید از فلش بیاره یا سشن عادی.  
دیگه لازم نیست ما بدونیم پشت صحنه چجوری ذخیره شده.

---
### متدهای کمکی نهایی

- متد **flush()** → کل سشن رو خالی می‌کنه:
```php
public static function flush() {
    $_SESSION = [];
}
```
- متد **destroy()** → کل سشن رو نابود می‌کنه (مثل logout):
 ```php
$_SESSION['_flashed']['errors'] = $errors;
header('Location: /login');
exit();  
  ```

---

✅ نتیجه:  
کدی که قبلاً شلوغ بود مثل:
```php
$_SESSION['_flashed']['errors'] = $errors;
header('Location: /login');
exit();
```

حالا خیلی تمیز می‌شه:
```php
Session::flash('errors', $errors);
return redirect('/laracast-php/public/login');
```

---
## متد logout
توی کلاس **Authenticator**، برای logout اینطوری نوشته بود:
```php
$_SESSION = [];  
session_destroy();  
$params = session_get_cookie_params();  
setcookie('PHPSESSID', '', time() - 3600,$params['path'],$params['domain'],$params['secure'],$params['httponly']);
```
این یعنی:
- کل داده‌های سشن خالی بشه
- خود سشن از بین بره
- کوکی session هم حذف بشه
  ولی خب اینا به **Session** مربوطه نه به **Authenticator**.
### انتقال به کلاس Session

جفری گفت بیایم این منطق رو تمیز کنیم و ببریمش داخل کلاس Session.  
پس یک متد جدید به اسم `destroy` ساخت:
```php
class Session
{
    // ... متدهای put, get, has, flash, unflash, flush ...

    public static function destroy()
    {
        // همه داده‌های session رو خالی کن
        $_SESSION = [];

        // اگه از کوکی برای session استفاده می‌کنیم، اونم پاک بشه
        if (ini_get("session.use_cookies")) {
            $params = session_get_cookie_params();
            setcookie(
                session_name(),
                '',
                time() - 42000,
                $params["path"],
                $params["domain"],
                $params["secure"],
                $params["httponly"]
            );
        }

        // خود session رو از بین ببر
        session_destroy();
    }
}
```
حالا توی **Authenticator** به جای اون کدهای تکراری، فقط می‌گه:
```php
Session::destroy();
```