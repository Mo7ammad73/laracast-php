این جلسه  درباره پیاده‌سازی **Middleware** در اپلیکیشن‌های PHP است. هدف این جلسه، جلوگیری از دسترسی کاربران به صفحات نامناسب (مثلاً یک کاربر لاگین کرده نباید وارد صفحه ثبت‌نام شود و بالعکس) است. در ادامه، کل مبحث جز به جز، دقیق و آموزشی تشریح شده است.

---
## تعریف مسئله

در این جلسه، مشکل اساسی این بود که بعد از ثبت‌نام و ورود کاربر، اگر دوباره بخواهد وارد صفحه ثبت‌نام شود و یک کاربر فرضی دیگر بسازد، وضعیت بهم می‌ریزد؛ یا بالعکس، فردی که مهمان است نباید بخش‌های مربوط به اعضا (مثل صفحه یادداشت‌ها) را ببیند.


وقتی کاربری ثبت نام می‌کند و وارد سیستم می‌شود، اما هنوز هم می‌تواند به صفحه ثبت نام دسترسی داشته باشد. این یک مشکل امنیتی است چون:
کاربر وارد شده نباید دوباره ثبت نام کند
کاربر غیر وارد شده نباید به صفحات اعضا دسترسی داشته باشد.

---
### هدف کلی جلسه: ایجاد دسترسی شرطی به صفحات (Authorization)

مشکل: کاربری که لاگین کرده (`$_SESSION['user']` دارد) همچنان می‌تواند به صفحه ثبت نام (`/register`) دسترسی داشته باشد و کاربر جدیدی ایجاد کند! این منطقی نیست. برعکس آن، کاربری که لاگین نکرده نباید به صفحه یادداشت‌ها (`/notes`) دسترسی داشته باشد.

راه‌حل: ایجاد یک لایه میانی (**Middleware**) که قبل از بارگذاری هر کنترلر، وضعیت کاربر (میهمان یا احراز هویت شده) را بررسی کند و در صورت لزوم، او را به صفحه دیگری (مثل صفحه اصلی) **هدایت** (Redirect) کند.

---

### **مفهوم** **Middleware**

در واقع Middleware مانند یک **پل** است که بین درخواست کاربر و اصل برنامه قرار می‌گیرد. این پل می‌تواند:
- بررسی کند کاربر وارد شده یا نه
- بررسی کند کاربر مهمان است یا نه
- بر اساس این بررسی‌ها، کاربر را هدایت کند.

- ---
- 
## راه‌حل قدم به قدم

## ۱. تعریف Middleware به صورت تابع در هر کنترلر

در ابتدا می‌شود در هر کنترلی بررسی کرد که کاربر اجازه ورود دارد یا نه، یعنی تو همه ی فایل های کنترلر (فایل های موجود در پوشه controller) کد زیر را بنویسیم ولی این باعث تکرار کد در کنترلرهای مختلف می‌شود؛ مثلاً در صفحه ثبت‌نام:
```php
if(! $_SESSION['user'] ?? false) {  
    header('location: /laracast-php/public/');  
    exit;  
}
```
این راه حل نامناسب و ضعیف هست.

---
## ۲. تعریف Middleware در سطح Route

ما در فایل `routes.php` به هر مسیر، یک **کلید** می‌دهیم تا مشخص کند کدام Middleware باید برای آن اجرا شود.
با اضافه کردن متد only به router می‌توان مشخص کرد که یک Route فقط قابل مشاهده برای نوع خاصی از کاربر است:

```php
$router->add('GET','/laracast-php/public/notes', "controller/note/index.php")->only('auth');
$router->get('/laracast-php/public/register' , "controller/registeration/create.php")->only('guest');
```
این کار باعث می‌شود تشخیص سطح دسترسی برای هر مسیر فقط با همین متد انجام شود و از انتشار کد جلوگیری شود.

دستور`->only('guest')`: یعنی این مسیر **فقط** برای میهمانان (کسانی که لاگین نکرده‌اند) قابل دسترسی است.
دستور`->only('auth')`: یعنی این مسیر **فقط** برای کاربران احراز هویت شده (لاگین کرده) قابل دسترسی است.

---
### نکته در مورد chain کردن

فرض کن میخوای یک ساندویچ درست کنی. مراحل اینه:
1. نون رو بذار روی بشقاب
2. کره بزن روش
3. پنیر بذار روش
4. سس بذار روش
   **در حالت عادی (بدون Chain):**
- هر بار باید بگویی **چیست** و چه کند.
- `$sandwich->putBread();` → "ساندویچ، نون بذار."
- `$sandwich->putButter();` → "ساندویچ، کره بزن."
- `$sandwich->putCheese();` → "ساندویچ، پنیر بذار."

**در حالت Chain:**
- فقط اول می‌گویی **چیست**، بعد فقط می‌گویی **چه کند**.
- `$sandwich->putBread()` → "ساندویچ، نون بذار."
- `->putButter()` → "...حالا کره بزن."
- `->putCheese();` → "...حالا پنیر بذار."
  دیگه اینجا sandiwich$ برای خط دوم و سوم نوشته نمیشه وقتی putButter<- میزنی انگار sandiwich$ رانوشتی.
  درواقع در chain همه چیز پشت سر هم انجام میشه ولی بدون chain دونه دونه انجام میشه.

---

## ۳. اصلاح کد Router

با توجه به اینکه متد only روی مسیرها گذاشتیم باید آن را در router تعریف کنیم در واقع باید کلاس Router را ویرایش کنیم.
متد add باید مقدار this را بازگرداند تا بتوان متد only را chain کرد:متد `add()` در کلاس `Router`، مسیرها را به آرایه `routes` اضافه می‌کند. اما هیچ چیزی برنمی‌گرداند `return` نمی‌کند. برای اینکه بتوانیم به صورت زنجیره‌ای از `->only()` استفاده کنیم (که به آن **Method Chaining** می‌گویند)، باید `add()` را تغییر دهیم تا `$this`  یعنی خود شیء را برگرداند.
پس به متد add رفته و در انتهایش دستور زیر را مینویسیم:
```php
return $this;
```
حالا با توجه به این تغییر باید تمام متدهایی که از متد add استفاده کردند را تغییر بدهیم.تغییری که میدهیم اینست که یک return قبل از دستوراتشان مینویسیم حالا من فقط متد patch را گذاشتم بقیه متدها هم به همین شکل هست:
```php
public function patch($uri , $controller) {  
    return $this->add('PATCH', $uri, $controller);  
}
```

## نکته
قبل از استفاده از متد only این را بگم که درآرایه routes ما یک فیلد middlware هم اضافه شد که مقدار پیش فرضش null هست و این فیلد توسط متد only مقداردهی میشود پس کد متد add به صورت زیر میشود:
```php
public function add($methods , $uri , $controller) {  
    foreach ((array)$methods as $method) {  
        $this->routes[] = [  
            'uri' => $uri,  
            'controller' => $controller,  
            'method' => $method ,  
            'middleware' => null  
        ];  
    }  
    return $this;  
}
```
### متد only
این متد میاد route یا مسیرهایی که روش این متد گذاشته شده رو فیلد middleware رو برابر با کلید کاربر و بقیه routeها یا مسیرها رو فیلد middleware برابر با null میشود. در واقع باید **آخرین route اضافه‌شده** رو بگیری و مقدار `middleware` اون رو برابر `$key` بزاری:
```php
public function only($key){  
    $this->routes[array_key_last($this->routes)]['middleware'] = $key;  
    return $this;  
    }
```
اما آرایه routes یک آرایه دو بعدی هست بعد اولش ایندکسی هست و بعد دومش کلید هست مثلا برای دسترسی به فلید middleware یکی از مسیرها مینویسیم :
```php
$this->routes[1]['middleware'];
```
پس در کد زیر :
```php
$this->routes[array_key_last($this->routes)]['middleware'] = $key;  
```
ابتدا آخرین ایندکس بعد اول را بدست می آوریم توسط تابع array_key_last که یک آرایه را میگرد و آخرین کلیدش را برمیگرداند بعد ما بعد دوم یعنی middleware را میخواهیم در نهایت این میگه تو آخرین مسیری که تو آرایه مقداردهی شده فیلد middleware اش رو برابر با کلید کاربر بذار.

---
## متد route
در این متد وقتی داری route پیدا می‌کنی، باید middleware رو هم بررسی کنی پس ابتدا بر روی آرایه routes یک حلقه foreach میزنیم.بعد بررسی میکنیم اگر url و متدی که کاربر داده با url و متد آرایه برابر بودپس  باید دو شرط دیگر را بررسی کرد:
```php
public function route($uri, $method) {  
    foreach ($this->routes as $route) {  
        if ($route['uri'] == $uri && $route['method'] == strtoupper($method)) {  
```
### 1- شرط middleware == guest (فقط برای مهمانان):

```php
	if ($route['middleware'] == 'guest') {  
	        if ($_SESSION['user'] ?? false) {// اگر سشن یوزر مقداردهی شده یعنی کاربر لاگین کرده       
	            header('location: /laracast-php/public/');  //برو به صفحه اصلی
                exit;  // و اجرای کد را متوقف کن
            }  
        }  // اگر کاربر لاگین نکرده بود، از این شرط بگذر و برو کنترلر را اجرا کن (صفحه ثبت نام را نشان بده)
  
```

- **هدف:** محافظت از صفحه‌هایی مثل ثبت نام و لاگین که فقط کاربران **لاگین نکرده** (مهمان) باید آن را ببینند.
-  **منطق:**  "اگر لاگین کرده‌ای، اینجا جای تو نیست. برو خانه!"

---

### 2- شرط middleware == auth (فقط برای کاربران لاگین‌کرده):

```php
if ($route['middleware'] == 'auth') {
    if (!$_SESSION['user'] ?? false) { // اگر کاربر لاگین نکرده بود (یعنی session وجود نداشت)...
        header('location: /laracast-php/public/'); // ...او را به صفحه اصلی بفرست
        exit; // و اجرای کد را متوقف کن
    }
}
// اگر کاربر لاگین کرده بود، از این شرطها بگذر و برو کنترلر را اجرا کن (مثلا یادداشت‌ها را نشان بده)
```


- **هدف:** محافظت از صفحه‌های داخلی برنامه مثل پنل کاربری، یادداشت‌ها و... که فقط کاربران **لاگین کرده** باید آن را ببینند.
- **منطق:** "اگر لاگین نکرده‌ای، اینجا جای تو نیست. برو خانه!"

---

### جمع‌بندی خیلی ساده:

| شرط                                | معنی                                           | اگر شرط درست بود                |
| ---------------------------------- | ---------------------------------------------- | ------------------------------- |
| **`guest`** + **`session exists`** | کاربر لاگین کرده می‌خواهد به صفحه مهمانان برود | **بیرون کن** (`header`, `exit`) |
| **`auth`** + **`no session`**      | کاربر لاگین نکرده می‌خواهد به صفحه اعضا برود   | **بیرون کن** (`header`, `exit`) |

**در هر دو حالت، اگر کاربر را بیرون نکنیم (`exit` نکنیم)، برنامه به خط بعدی می‌رود و کنترلر را اجرا می‌کند (یعنی صفحه را نشان می‌دهد).**

با این شرایط، مسیرها بر اساس وضعیت کاربر (مهمان یا عضو) قابل دسترسی هستند.

---
### **خارج کردن منطق Middleware به کلاس‌های مجزا**

برای منظم کردن کد و امکان اضافه کردن Middleware‌های جدید به راحتی، منطق `auth` و `guest` را در کلاس‌های جداگانه قرار می‌دهیم.
در پوشه Core یک پوشه با نام middleware ایجاد میکنیم و درونش سه فایل auth.php-guest.php و middleware.php را ایجاد میکنیم.
دو کلاس auth و guest را ساختیم تا دیگر شرط ها از متد route حذف شده و به این کلاس ها منتقل شوند.
#### کلاس auth
```php
namespace core\middleware;  
class Auth{  
    public function handle(){  
        if(! $_SESSION['user'] ?? false) {  
            header('location: /laracast-php/public/');  
            exit;  
        }  
    }  
}
```
#### کلاس guest
```php
    namespace core\middleware;  
    class Guest{  
        public function handle(){  
            if($_SESSION['user'] ?? false) {  
                header('location: /laracast-php/public/');  
                exit;  
            }  
        }  
  
    }
```

---
## ۶. فراخوانی کلاس‌ها در Router

دو شرطی که در متدroute تعریف کردیم را برمیداریم و در این کلاس ها مینویسیم و به جای آن دو شرط در متد route کد زیر را مینویسیم:
کد بخش route اینگونه تغییر می‌کند تا ابتدا اگر middleware تنظیم شده، کلاس مربوطه را instantiate و متد handle را صدا بزند:
```php
if($route['middleware'] == 'guest') {  
    (new Guest)->handle();  
  
}  
if($route['middleware'] == 'auth') {  
    (new Auth)->handle();  
  
}
```
اینگونه کد مرتب‌تر و قابل توسعه‌تر می‌شود.

---
## ۷. ساخت کلاس مرکزی Middleware

برای جلوگیری از تکرار، یک کلاس مرکزی ساخته می‌شود:
```php
<?php  
    namespace core\middleware;  
    class Middleware{  
        public const MAP= [  
            'guest' => Guest::class,  
            'auth' => Auth::class  
        ];  
  
        public  static function resolve($key)  
        {  
            if(! $key){  
                return;  
            }  
            $middleware = static::MAP[$key] ?? false;  
            if(! $middleware){  
                throw new \Exception("Middleware not found for key: ".$key);  
            }  
            (new $middleware)->handle();  
        }  
    }
```
**نکته مهم****: متد `resolve` به صورت `static` تعریف شده، پس آن را مستقیماً با `Middleware::resolve()` صدا می‌زنیم بدون نیاز به ساختن شیء.
و حالا در فایل Router اینگونه فراخوانی می‌شود:
```php
if($route['middleware']) {  
    Middleware::resolve($route['middleware']);  
}
```
به این صورت، هر نوع middleware جدیدی را فقط در MAP اضافه می‌کنی و تمام.

---
## ۸. مدیریت خطاها و افزودن Middleware جدید

اگر کلید اشتباه (مثلاً foobar) به only بدهید، اپلیکیشن خطا می‌دهد که آن نوع middleware تعریف نشده است.
برای افزودن Middleware جدید:
- یک کلاس جدید در پوشه middleware بساز و در MAP اضافه کن
- در routes از only با کلید جدیدت استفاده کن
- خودش خودکار وصل می‌شود و اجرا می‌شود.
## کاربرد عملی

اگر بخواهی صفحاتی فقط برای اعضا یا فقط برای مهمان‌ها باشد، کافی است متد only را در routes استفاده کنی و کلاس مربوطه را بسازی و در MAP قرار دهی.